## Сервис авторизации

### Спринт 7 - Исправления после ревью:

1) Имена провайдеров в виде enum: [ссылка на строки в коммите](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-05b21c22714165b86192346a9b2b8bbebbbb49419a5c0a6ed6a552a6f3c188c5R54)
2) Добавил типизацию: [ссылка на строки в коммите](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-2ef609af76559dde6144d6d44224c468b327d7779b63ed32a7be88574a1f70d5R135)
3) Перенёс ендпоинты OAuth провайдеров в env: [здесь](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-a714eca19b6f8db4dbfbd978aa5325b98cc0550fe4c1e7953e8b1eb136cb925aR21) и [здесь](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-05b21c22714165b86192346a9b2b8bbebbbb49419a5c0a6ed6a552a6f3c188c5R70)
4) Унификация авторизации через OAuth: [классы](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-05b21c22714165b86192346a9b2b8bbebbbb49419a5c0a6ed6a552a6f3c188c5R9-R51) для работы с провайдерами (базовый абстрактный и две его реализации для google и yandex) и унификация ендпоинтов: [логин](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-8078488b461eff1ee0af85396bcf915538c9eae5fa118097288311cc0101f688R169) и [auth для редиректа](https://github.com/SergeyP1990/auth-api/commit/2491cd465dbbe5ca21dad569a8a62f140bc47093#diff-8078488b461eff1ee0af85396bcf915538c9eae5fa118097288311cc0101f688R194)
5) Ограничение количества запросов: [коммит](https://github.com/SergeyP1990/auth-api/pull/38/commits/853255b7783bd94f248c4f2759e45b39f5afba62)

### Спринт 7

1) OAuth аутентификация - https://github.com/SergeyP1990/auth-api/issues/28
2) Интеграция с async-api - https://github.com/SergeyP1990/auth-api/issues/29
3) Трассировка - https://github.com/SergeyP1990/auth-api/issues/30
4) Партицирование - https://github.com/SergeyP1990/auth-api/issues/31

Авторизация через OAuth доступна через сервис `google` и `yandex` на ендпоинтах `/user/oauth/login/google` и `/user/oauth/login/yandex` соответственно. Для работы необходимо указать клиентские id и secret в .env файле (как в [примере](https://github.com/SergeyP1990/auth-api/blob/ef66674e75a4dfab746a27f2b6adc6545e0c16df/example.env#L18-L22))

Интеграция с сервисом `async-api` затрагивает изменения в репозитории async-api, а именно этот [pull request](https://github.com/SergeyP1990/async-api/commit/5c1acebb1caa454ecdc66efee571e8b70c58b6d1) (и небольшой [фикс](https://github.com/SergeyP1990/async-api/commit/7834d3f9d1a81c58b230c686d29c39dfeead534d) для него следом). Фильмам в `async-api` выставляются флаги с требованием подписки `subscribe_required`. Наличие роли `subscriber` у пользователя позволяет ему получить доступ к фильму, а отсутствие этой роли приводит к возврату ошибки.

### Требования:
  - python3 >= 3.8.10
  - [docker-compose](https://docs.docker.com/compose/install/) >= 1.29.2

### Установка:
1) Склонировать репозиторий
`git clone https://github.com/SergeyP1990/auth-api`
2) На примере .env_example создать в корне репозитория файл .env и заполнить его необходимыми данными
3) Далее перейти в директорию с репозиторием и запустить docker-compose
  ```
  cd auth-api
  docker-compose up -d --build
  ```
 4) Выполнить первоначальные миграции. Для этого выполнить команды:
  ```
  docker-compose exec auth-api flask db migrate -m "initial"
  docker-compose exec auth-api flask db upgrade
  ```


### Описание:

Ознакомиться с описанием openapi можно по [ссылке](https://github.com/SergeyP1990/auth-api/blob/0450aaac4cc5b8c31cd706469ae70ca50311b67b/open_api_spec.yml) ([SwaggerHub](https://app.swaggerhub.com/apis/myteam8896/auth-api/1.0.0))

Сервис предоставляет возможность идентификации, аутентификации, авторизации и регистрации пользователей. Информация о пользователях хранится в базе данных Postgres в таблице `users`. Пароли хранятся в хэшированном виде.

#### Идентификация и аутентификация

Для поддержания сессии залогиненного пользователя сервис использует JWT токены. Access и refresh токены выдаются пользователю после логина. Вместе с ними выдаются csrf токены, которые необходимо предъявлять сервису при запросах в заголовках. Access токен короткоживущий, содержит идентификатор пользователя и используется для доступа к ендпоинтам, refresh токен существует дольше (время действия токенов указывается в настройках через .env), является одноразовым и используется при окончании срока жизни access токена для создания новой пары access и refresh токенов.

Refresh токен хранится в Redis в db1, в db0 хранятся access токены, которые были использованы при `logout`.

#### Авторизация

В сервисе реализовано ограничение прав пользователей. В базе данных Postgres хранятся роли в таблице `roles`, а ассоциирование ролей с пользователями осуществялется через таблицу `user_role`. После предъявления JWT токена на ендпоинте происходит извлечение идентификатора пользователя из токена и проверка его текущих прав на действия в этом ендпоинте. 

#### Защита ендпоинтов
##### Защита ендпоинтов сервиса авторизации

Защита ендпоинтов сервиса (CRUD ролей и изменение данных пользователей) реализована в самом коде сервиса. Для доступа к CRUD ролей и изменением данных пользователей (пользователь может изменять данные сам себе без проверки роли) пользователь должен обладать ролью `admin`. Помимо этого в базе данных присутствует роль `superadmin`, позволяющая пользователю с этой ролью всегда успешно проходить авторизацию.

###### Суперпользователь

Суперпользователь обладает разершением на любые действия в сервисе. Назначить роль `superadmin` пользователю можно либо через API /role, либо через командную строку. Для назначения роли `superadmin` пользователю через консоль необходимо:
1) Подключиться к контейнеру сервиса авторизации, выполнив команду `docker-compose exec auth-api "/bin/bash"`
2) В контейнере выполнить команду `python3 app.py grant-superuser <user_name>`, где `<user_name>` - логин пользователя, которому вы хотите выдать права суперпользователя.

Так же через консоль можно создавать пользователей. Синтаксис команды: `python3 app.py register-user <user_name> <password>`

##### Защита ендпоинтов стороннего сервиса

Для проверки возможности доступа у какому-либо ресурсу сторонний сервис может выполнить запрос к ендпоинту /role/user/{user_id}/role/{role_id}. Для выполнения проверки необходимо предоставить jwt токен с идентификатором пользователя, у которого есть либо роль `admin`, либо роль `role_checker`
<details>
  <summary>Дефолтное сообщение из репы спринта</summary>
# Проектная работа 6 спринта

С этого модуля вы больше не будете получать чётко расписанное ТЗ, а задания для каждого спринта вы найдёте внутри уроков. Перед тем как начать программировать, вам предстоит продумать архитектуру решения, декомпозировать задачи и распределить их между командой.

В первом спринте модуля вы напишете основу вашего сервиса и реализуете все базовые требования к нему. Старайтесь избегать ситуаций, в которых один из ваших коллег сидит без дела. Для этого вам придётся составлять задачи, которые можно выполнить параллельно и выбрать единый стиль написания кода.

К концу спринта у вас должен получиться сервис авторизации с системой ролей, написанный на Flask с использованием gevent. Первый шаг к этому — проработать и описать архитектуру вашего сервиса. Это значит, что перед тем, как приступить к разработке, нужно составить план действий: из чего будет состоять сервис, каким будет его API, какие хранилища он будет использовать и какой будет его схема данных. Описание нужно сдать на проверку. Вам предстоит выбрать, какой метод организации доступов использовать для онлайн-кинотеатра, и систему прав, которая позволит ограничить доступ к ресурсам. 

Для описания API рекомендуем использовать [OpenAPI](https://editor.swagger.io){target="_blank"}, если вы выберете путь REST. Или используйте текстовое описание, если вы планируете использовать gRPC. С этими инструментами вы познакомились в предыдущих модулях. Обязательно продумайте и опишите обработку ошибок. Например, как отреагирует ваш API, если обратиться к нему с истёкшим токеном? Будет ли отличаться ответ API, если передать ему токен с неверной подписью? А если имя пользователя уже занято? Документация вашего API должна включать не только ответы сервера при успешном завершении запроса, но и понятное описание возможных ответов с ошибкой.

После прохождения ревью вы можете приступать к программированию. 

Для успешного завершения первой части модуля в вашем сервисе должны быть реализованы API для аутентификации и система управления ролями. Роли понадобятся, чтобы ограничить доступ к некоторым категориям фильмов. Например, «Фильмы, выпущенные менее 3 лет назад» могут просматривать только пользователи из группы 'subscribers'.  

## API для сайта и личного кабинета

- регистрация пользователя;
- вход пользователя в аккаунт (обмен логина и пароля на пару токенов: JWT-access токен и refresh токен); 
- обновление access-токена;
- выход пользователя из аккаунта;
- изменение логина или пароля (с отправкой email вы познакомитесь в следующих модулях, поэтому пока ваш сервис должен позволять изменять личные данные без дополнительных подтверждений);
- получение пользователем своей истории входов в аккаунт;

## API для управления доступами

- CRUD для управления ролями:
  - создание роли,
  - удаление роли,
  - изменение роли,
  - просмотр всех ролей.
- назначить пользователю роль;
- отобрать у пользователя роль;
- метод для проверки наличия прав у пользователя. 

## Подсказки

1. Продумайте, что делать с анонимными пользователями, которым доступно всё, что не запрещено отдельными правами.
2. Метод проверки авторизации будет всегда нужен пользователям. Ходить каждый раз в БД — не очень хорошая идея. Подумайте, как улучшить производительность системы.
3. Добавьте консольную команду для создания суперпользователя, которому всегда разрешено делать все действия в системе.
4. Чтобы упростить себе жизнь с настройкой суперпользователя, продумайте, как сделать так, чтобы при авторизации ему всегда отдавался успех при всех запросах.
5. Для реализации ограничения по фильмам подумайте о присвоении им какой-либо метки. Это потребует небольшой доработки ETL-процесса.


## Дополнительное задание

Реализуйте кнопку «Выйти из остальных аккаунтов», не прибегая к хранению в БД активных access-токенов.

## Напоминаем о требованиях к качеству

Перед тем как сдать ваш код на проверку, убедитесь, что 

- Код написан по правилам pep8: при запуске [линтера](https://semakin.dev/2020/05/python_linters/){target="_blank"} в консоли не появляется предупреждений и возмущений;
- Все ключевые методы покрыты тестами: каждый ответ каждой ручки API и важная бизнес-логика тщательно проверены;
- У тестов есть понятное описание, что именно проверяется внутри. Используйте [pep257](https://www.python.org/dev/peps/pep-0257/){target="_blank"}; 
- Заполните README.md так, чтобы по нему можно было легко познакомиться с вашим проектом. Добавьте короткое, но ёмкое описание проекта. По пунктам опишите как запустить приложения с нуля, перечислив полезные команды. Упомяните людей, которые занимаются проектом и их роли. Ведите changelog: описывайте, что именно из задания модуля уже реализовано в вашем сервисе и пополняйте список по мере развития.
- Вы воспользовались лучшими практиками описания конфигурации приложений из урока. 
<details>
